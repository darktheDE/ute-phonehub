# USE CASE SPECIFICATION - QUẢN LÝ GIỎ HÀNG

Tài liệu này mô tả các use case nghiệp vụ chính của module Giỏ hàng ở mức hành vi người dùng và phản hồi hệ thống.
Các chi tiết kỹ thuật (SQL, retry, WebSocket, Redis lock, ...) sẽ nằm trong tài liệu thiết kế, không trình bày chi tiết ở đây.

---

## 1.1. Thêm sản phẩm vào giỏ hàng

| Thuộc tính | Mô tả |
| --- | --- |
| Mã Use Case | UC-CART-01 |
| Tên Use Case | Thêm sản phẩm vào giỏ hàng |
| Actor | Registered Customer |
| Trigger | Actor chọn nút "Thêm vào giỏ hàng" trên trang chi tiết sản phẩm |
| Mô tả ngắn | Cho phép khách hàng thêm sản phẩm điện thoại vào giỏ hàng với số lượng mong muốn. Nếu sản phẩm đã có trong giỏ, hệ thống tự động cộng dồn số lượng. |
| Điều kiện tiên quyết | Actor đã đăng nhập thành công và sản phẩm còn tồn tại trong hệ thống. |

### Kết quả sau cùng

- Sản phẩm được thêm vào giỏ hàng hoặc số lượng được cập nhật.
- Tổng tiền giỏ hàng được tính toán lại.
- Badge số lượng giỏ hàng trên header được cập nhật.

### Luồng sự kiện chính

1. Từ trang chi tiết sản phẩm, Actor chọn số lượng muốn mua (mặc định = 1).
2. Actor nhấn nút "Thêm vào giỏ hàng".
3. Hệ thống xác thực người dùng từ JWT token.
4. Hệ thống kiểm tra sản phẩm tồn tại trong database và đang ở trạng thái ACTIVE.
5. Hệ thống kiểm tra tồn kho: `product.stock_quantity >= requested_quantity`.
6. Hệ thống lấy giỏ hàng hiện tại của Actor:
	 - Nếu chưa có Cart: tạo mới gắn với `user_id`.
	 - Nếu đã có Cart: sử dụng Cart hiện tại.
7. Hệ thống kiểm tra sản phẩm trong giỏ:
	 - Nếu sản phẩm đã có trong giỏ: cập nhật `quantity = old_quantity + new_quantity` (không vượt quá giới hạn tối đa trên mỗi sản phẩm).
	 - Nếu chưa có: tạo CartItem mới với số lượng yêu cầu.
8. Hệ thống lưu thay đổi giỏ hàng.
9. Hệ thống tính toán lại:
	 - `subtotal = price × quantity` cho từng item.
	 - `totalAmount = SUM(all subtotals)`.
	 - `itemCount` = tổng số dòng sản phẩm trong giỏ.
10. Hệ thống trả về `CartResponse` với thông tin giỏ hàng cập nhật.
11. UI hiển thị thông báo thành công "Đã thêm vào giỏ hàng" và cập nhật badge.

### Luồng phụ (Alternate Flow)

- AF1 – Chưa đăng nhập:
	1. Ở bước 3, nếu Actor chưa đăng nhập, hệ thống yêu cầu đăng nhập.
	2. Sau khi đăng nhập thành công, Actor được điều hướng lại trang sản phẩm và có thể thực hiện lại thao tác thêm vào giỏ.

- AF2 – Tồn kho không đủ:
	1. Ở bước 5, nếu `stock_quantity < requested_quantity`, hệ thống trả về lỗi nghiệp vụ kèm thông tin số lượng còn lại.
	2. UI hiển thị "Chỉ còn X sản phẩm trong kho" và vô hiệu hóa thao tác thêm với số lượng đó.

- AF3 – Vượt quá giới hạn tối đa mỗi sản phẩm:
	1. Ở bước 7, nếu `old_quantity + new_quantity` vượt quá giới hạn (ví dụ 10), hệ thống trả về lỗi nghiệp vụ "Chỉ được mua tối đa N sản phẩm" và không thay đổi giỏ.

- AF4 – Merge giỏ hàng tạm sau khi đăng nhập:
	1. Nếu Actor vừa đăng nhập và client gửi kèm guest cart (giỏ tạm trong localStorage), hệ thống nhận danh sách item tạm.
	2. Hệ thống merge các item vào user cart, kiểm tra tồn kho và giới hạn số lượng.
	3. Các item không hợp lệ (hết hàng, không tồn tại) được bỏ qua.
	4. Hệ thống trả về thông điệp dạng "Đã đồng bộ X sản phẩm từ giỏ hàng tạm".

### Luồng lỗi (Exception Flow)

- EF1 – Sản phẩm không tồn tại hoặc bị xóa: hệ thống trả về 404 Not Found với thông điệp "Sản phẩm không tồn tại".
- EF2 – Lỗi hệ thống (lỗi database, dịch vụ nội bộ, ...): hệ thống trả về mã lỗi 5xx và thông điệp tổng quát "Có lỗi xảy ra, vui lòng thử lại".
- EF3 – Optimistic locking conflict: nếu giỏ hàng bị cập nhật đồng thời từ phiên khác, hệ thống có thể retry; nếu vẫn không thành công, trả về 409 Conflict kèm trạng thái giỏ mới nhất để UI reload.

---

## 1.2. Xem giỏ hàng

| Thuộc tính | Mô tả |
| --- | --- |
| Mã Use Case | UC-CART-02 |
| Tên Use Case | Xem giỏ hàng |
| Actor | Registered Customer |
| Trigger | Actor chọn icon "Giỏ hàng" trên header hoặc truy cập `/cart` |
| Mô tả ngắn | Cho phép khách hàng xem danh sách đầy đủ các sản phẩm trong giỏ, cùng giá, số lượng, thành tiền và tổng tiền. |
| Điều kiện tiên quyết | Actor đã đăng nhập thành công vào hệ thống. |

### Kết quả sau cùng

- Danh sách sản phẩm trong giỏ được hiển thị đầy đủ.
- Trạng thái tồn kho hiển thị khớp với dữ liệu hiện tại.
- Tổng tiền được tính toán chính xác.

### Luồng sự kiện chính

1. Actor truy cập trang `/cart` hoặc click icon "Giỏ hàng" trên header.
2. Hệ thống xác thực người dùng từ JWT token.
3. Hệ thống lấy Cart và danh sách CartItem tương ứng với user hiện tại (kèm thông tin Product).
4. Với mỗi item trong giỏ, hệ thống kiểm tra:
	 - Nếu `product.stock_quantity == 0`: đánh dấu sản phẩm "Hết hàng" trong dữ liệu trả về.
	 - Nếu `cart_item.quantity > product.stock_quantity`: đánh dấu cảnh báo "Số lượng vượt quá tồn kho".
5. Hệ thống tính toán `subtotal` cho từng item và `totalAmount` cho toàn giỏ.
6. Hệ thống trả về `CartResponse` chứa toàn bộ thông tin cần hiển thị (danh sách item, tổng tiền, số dòng sản phẩm, tồn kho hiện tại).
7. UI hiển thị danh sách sản phẩm, nút tăng/giảm số lượng, nút xóa từng sản phẩm, tổng tiền và nút "Thanh toán".

### Luồng phụ (Alternate Flow)

- AF1 – Giỏ hàng trống:
	1. Ở bước 3, nếu không có CartItem, hệ thống trả về giỏ rỗng.
	2. UI hiển thị empty state với thông điệp "Giỏ hàng của bạn đang trống" và nút "Tiếp tục mua sắm".

- AF2 – Sản phẩm không còn tồn tại:
	1. Ở bước 4, nếu CartItem trỏ tới sản phẩm đã bị xóa, hệ thống loại bỏ item đó khỏi giỏ.
	2. Hệ thống có thể trả về thông tin tổng quát dạng "Một số sản phẩm không còn tồn tại đã bị xóa khỏi giỏ hàng".

- AF3 – Giá sản phẩm thay đổi:
	1. Ở bước 5, hệ thống luôn sử dụng giá mới nhất từ Product.
	2. Client có thể hiển thị badge hoặc ghi chú "Giá đã thay đổi" cạnh sản phẩm nếu giá khác lần trước khách hàng xem.

### Luồng lỗi (Exception Flow)

- EF1 – Lỗi truy xuất dữ liệu (timeout, lỗi kết nối, ...): hệ thống trả về lỗi 5xx; UI hiển thị thông báo "Không thể tải giỏ hàng, vui lòng thử lại" và cho phép Actor thực hiện lại.
- EF2 – Dữ liệu một phần (CartItem tồn tại nhưng Product null): hệ thống coi các CartItem đó là dữ liệu lỗi, loại bỏ và trả về giỏ đã được làm sạch.
- EF3 – Truy cập đồng thời từ nhiều thiết bị: hệ thống sử dụng optimistic locking hoặc cơ chế realtime (sự kiện CartUpdated, WebSocket, ...) để đảm bảo client luôn có trạng thái mới nhất. Chi tiết kỹ thuật mô tả ở tài liệu khác.

---

## 1.3. Cập nhật số lượng sản phẩm

| Thuộc tính | Mô tả |
| --- | --- |
| Mã Use Case | UC-CART-03 |
| Tên Use Case | Cập nhật số lượng sản phẩm |
| Actor | Registered Customer |
| Trigger | Actor tăng/giảm số lượng hoặc nhập trực tiếp số lượng trên UI giỏ hàng |
| Mô tả ngắn | Cho phép khách hàng thay đổi số lượng sản phẩm trong giỏ hàng. Nếu số lượng về 0, sản phẩm sẽ bị xóa. |
| Điều kiện tiên quyết | Actor đang ở trang giỏ hàng và sản phẩm đã có trong giỏ. |

### Kết quả sau cùng

- Số lượng sản phẩm trong giỏ được cập nhật.
- Tổng tiền được tính lại.
- Nếu số lượng bằng 0, sản phẩm bị xóa khỏi giỏ.

### Luồng sự kiện chính

1. Actor thay đổi số lượng (bằng nút +/− hoặc nhập trực tiếp).
2. UI (có thể) cập nhật tạm thời số lượng hiển thị (optimistic update).
3. UI gửi request `PUT /api/v1/cart/items/{itemId}` với payload `{ quantity: new_value }`.
4. Hệ thống xác thực người dùng.
5. Hệ thống kiểm tra quyền sở hữu: CartItem phải thuộc Cart của user hiện tại; nếu không, từ chối với lỗi 403.
6. Nếu `new_quantity == 0`, hệ thống xóa CartItem khỏi giỏ và tính lại tổng tiền.
7. Nếu `new_quantity > 0`, hệ thống kiểm tra tồn kho: `product.stock_quantity >= new_quantity`.
8. Nếu hợp lệ, hệ thống cập nhật quantity, lưu CartItem, tính lại tổng tiền.
9. Hệ thống trả về `CartResponse` mới.
10. UI cập nhật lại giao diện theo dữ liệu mới từ server.

### Luồng phụ (Alternate Flow)

- AF1 – Vượt tồn kho:
	1. Ở bước 7, nếu `new_quantity > stock_quantity`, hệ thống trả về lỗi 4xx kèm thông tin `availableStock`.
	2. UI rollback về số lượng cũ và hiển thị "Chỉ còn X sản phẩm".

- AF2 – Đưa số lượng về 0:
	1. Khi Actor giảm quantity về 0, hệ thống thực hiện logic xóa item tương tự UC 1.4.
	2. UI loại bỏ item khỏi danh sách sau khi server xác nhận.

- AF3 – CartItem không thuộc về user:
	1. Ở bước 5, nếu CartItem không thuộc Cart của user, hệ thống trả về 403 Forbidden với thông điệp phù hợp.

### Luồng lỗi (Exception Flow)

- EF1 – Hết hàng trong lúc cập nhật: nếu server phát hiện sản phẩm đã hết hàng, UI cần rollback optimistic update và hiển thị thông báo lỗi.
- EF2 – Optimistic locking conflict: nếu giỏ hàng bị cập nhật bởi phiên khác, hệ thống có thể retry; nếu vẫn conflict, trả về 409 cùng trạng thái giỏ mới nhất để UI reload.
- EF3 – Lỗi hệ thống (deadlock, lỗi database, ...): sau khi retry nhiều lần không thành công, hệ thống trả về lỗi 5xx với thông điệp "Không thể cập nhật, vui lòng thử lại".

---

## 1.4. Xóa sản phẩm khỏi giỏ hàng

| Thuộc tính | Mô tả |
| --- | --- |
| Mã Use Case | UC-CART-04 |
| Tên Use Case | Xóa sản phẩm khỏi giỏ hàng |
| Actor | Registered Customer |
| Trigger | Actor chọn nút "Xóa" trên một sản phẩm trong giỏ |
| Mô tả ngắn | Cho phép khách hàng xóa một sản phẩm cụ thể khỏi giỏ hàng. |
| Điều kiện tiên quyết | Actor đang ở trang giỏ hàng và sản phẩm có trong giỏ. |

### Kết quả sau cùng

- Sản phẩm được xóa khỏi giỏ.
- Tổng tiền và `itemCount` được cập nhật.

### Luồng sự kiện chính

1. Actor click nút "Xóa" (icon thùng rác) trên sản phẩm trong giỏ.
2. UI (theo thiết kế UX) có thể hiển thị hộp thoại xác nhận với nội dung hỏi lại người dùng.
3. Actor xác nhận xóa.
4. UI gửi request `DELETE /api/v1/cart/items/{itemId}`.
5. Hệ thống xác thực người dùng.
6. Hệ thống kiểm tra quyền sở hữu: CartItem phải thuộc về Cart của user hiện tại.
7. Hệ thống xóa CartItem tương ứng khỏi giỏ và tính lại `totalAmount` và `itemCount`.
8. Hệ thống trả về `CartResponse` mới.
9. UI remove item khỏi danh sách và hiển thị thông báo "Đã xóa sản phẩm".

### Luồng phụ (Alternate Flow)

- AF1 – Người dùng hủy xóa:
	1. Ở bước 2, nếu Actor chọn "Hủy", UI đóng dialog và không gửi request.

- AF2 – Hỗ trợ hoàn tác (undo):
	1. Sau bước 9, UI có thể hiển thị nút "Hoàn tác" trong một khoảng thời gian ngắn.
	2. Nếu Actor chọn "Hoàn tác", UI gửi request thêm lại sản phẩm với số lượng cũ (logic giống UC 1.1).

### Luồng lỗi (Exception Flow)

- EF1 – CartItem đã bị xóa ở nơi khác: khi gọi `DELETE`, nếu CartItem không còn tồn tại, hệ thống có thể trả về 404 hoặc coi là thao tác không có tác dụng; UI vẫn loại bỏ item khỏi danh sách và không cần hiển thị lỗi.
- EF2 – Lỗi hệ thống khi xóa (ví dụ do ràng buộc khóa ngoại): hệ thống rollback và trả về lỗi 5xx với thông điệp "Không thể xóa, vui lòng thử lại sau".

---

## 1.5. Xóa toàn bộ giỏ hàng

| Thuộc tính | Mô tả |
| --- | --- |
| Mã Use Case | UC-CART-05 |
| Tên Use Case | Xóa toàn bộ giỏ hàng |
| Actor | Registered Customer |
| Trigger | Actor chọn nút "Xóa tất cả" ở giao diện giỏ hàng |
| Mô tả ngắn | Cho phép khách hàng xóa toàn bộ sản phẩm trong giỏ hàng bằng một thao tác. |
| Điều kiện tiên quyết | Giỏ hàng hiện có ít nhất một sản phẩm. |

### Kết quả sau cùng

- Tất cả CartItem trong giỏ bị xóa.
- Giỏ hàng ở trạng thái rỗng (`totalAmount = 0`, `itemCount = 0`).
- Cart entity gắn với user vẫn tồn tại (chỉ xóa items).

### Luồng sự kiện chính

1. Actor click nút "Xóa tất cả" trên UI giỏ hàng.
2. UI hiển thị hộp thoại xác nhận với cảnh báo rõ ràng (có thể yêu cầu Actor nhập "XOA" hoặc hành động tương tự để xác nhận).
3. Actor xác nhận xóa toàn bộ.
4. UI gửi request `DELETE /api/v1/cart/clear`.
5. Hệ thống xác thực người dùng.
6. Hệ thống lấy Cart tương ứng với user hiện tại.
7. Hệ thống xóa toàn bộ CartItem thuộc Cart đó (có thể xử lý theo batch nếu giỏ rất lớn, chi tiết ở thiết kế kỹ thuật).
8. Hệ thống trả về `CartResponse` rỗng (danh sách items trống, tổng tiền = 0).
9. UI hiển thị trạng thái giỏ hàng trống và thông báo "Đã xóa toàn bộ giỏ hàng".

### Luồng phụ (Alternate Flow)

- AF1 – Người dùng không xác nhận xóa: ở bước 2, nếu Actor chọn "Hủy" hoặc không nhập đúng mã xác nhận, không có request xóa nào được gửi và giỏ hàng giữ nguyên.

- AF2 – Tự động xóa giỏ sau khi đặt hàng thành công: sau khi Order được tạo thành công ở module Đơn hàng, hệ thống có thể tự động gọi logic clear cart cho user tương ứng mà không yêu cầu xác nhận thêm.

### Luồng lỗi (Exception Flow)

- EF1 – Giỏ rất lớn gây nguy cơ timeout: hệ thống áp dụng cơ chế xóa theo lô (batch) hoặc xử lý phù hợp để tránh khóa hệ thống quá lâu.
- EF2 – Cập nhật đồng thời: nếu có thao tác khác đang thêm sản phẩm trong khi xóa, hệ thống sử dụng cơ chế lock/điều phối ở tầng kỹ thuật (ví dụ: Redis lock) để tránh race condition.
- EF3 – Đang tồn tại tiến trình khác sử dụng CartItem (ví dụ: đang tạo Order): hệ thống có thể từ chối xóa và trả về lỗi nghiệp vụ phù hợp (ví dụ: "Không thể xóa vì có đơn hàng đang xử lý").

---

## 2. Tổng quan API giỏ hàng (tóm tắt)

Các endpoint chính (đã được hiện thực trong backend):

- `GET /api/v1/cart/me`
	- Lấy giỏ hàng hiện tại của user.
	- Yêu cầu: Bearer token hợp lệ.
	- Response: `ApiResponse<CartResponse>`.

- `POST /api/v1/cart/items`
	- Thêm sản phẩm vào giỏ hoặc cộng dồn số lượng.
	- Body: `{ productId: Long, quantity: number (1–10) }`.
	- Response: `ApiResponse<CartResponse>`.

- `PUT /api/v1/cart/items/{itemId}`
	- Cập nhật số lượng một item trong giỏ.
	- Body: `{ quantity: number (0–10) }`.
	- Response: `ApiResponse<CartResponse>`.

- `DELETE /api/v1/cart/items/{itemId}`
	- Xóa một item khỏi giỏ.
	- Response: `ApiResponse<CartResponse>`.

- `DELETE /api/v1/cart/clear`
	- Xóa toàn bộ sản phẩm trong giỏ của user hiện tại.
	- Response: `ApiResponse<CartResponse>` (giỏ rỗng).

- `POST /api/v1/cart/merge`
	- Merge guest cart (giỏ tạm trên client) vào giỏ hàng của user sau khi đăng nhập.
	- Body: danh sách item tạm thời từ client.
	- Response: `ApiResponse<MergeCartResponse>` (bao gồm cart sau khi merge và số lượng item được merge/bỏ qua).

---

## 3. Cấu trúc dữ liệu chính (tóm tắt)

- CartResponse (trả về trong hầu hết API giỏ hàng):
	- `id: Long` – ID giỏ hàng.
	- `items: CartItemResponse[]` – danh sách sản phẩm trong giỏ.
	- `totalAmount: number` – tổng tiền hiện tại của giỏ.
	- `itemCount: number` – số dòng sản phẩm trong giỏ.

- CartItemResponse:
	- `id: Long` – ID CartItem.
	- `productId: Long` – ID sản phẩm.
	- `productName: string` – tên sản phẩm.
	- `productThumbnailUrl: string` – URL ảnh đại diện.
	- `unitPrice: number` – đơn giá.
	- `quantity: number` – số lượng trong giỏ.
	- `subtotal: number` – thành tiền cho item (`unitPrice × quantity`).
	- `stockQuantity: number` – tồn kho hiện tại (để client hiển thị hết hàng / thiếu hàng).

Các field nâng cao khác (như timestamp, version, flag realtime, ...) nếu được thêm vào sau này cần được cập nhật đồng bộ trong mã nguồn và tài liệu này.
